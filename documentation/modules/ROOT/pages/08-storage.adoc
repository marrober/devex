= Adding Container Storage
:navtitle: Adding container Storage

[#ephemeral_container_storage]
== Ephemeral Container Storage

Containers by their nature are ephemeral – they are short lived compute units with no data persistence. Any data a container works with or produces is held within runtime memory – as a result of which stopping or restarting a container results in data loss.

Although containers appear to have a file system, this by default is an in memory file system. In the following screen shot, you can see the root directory structure from within our container, which is used by our java application - this is all within volatile memory.

image::08-01-container-filesystem.png[container root filesystem,700,align="center"]


[#container_volumes]
== Container Volumes


However, applications are only part of the puzzle when trying to build something useful – we need data. Part of this challenge is resolved by using volumes, which can be attached to containers. In its simplest form, a container volume is simply a folder accessible to the host that the container runs on, which is mapped to a folder within the container. For example:


On host:

[.console-output]
[source,bash]
----
/mnt/data/
----

Within container:
[.console-output]
[source,bash]
----
/mnt/database/
----


Joining them together:

[.console-output]
[source,bash]
----
podman run –-name mycotainer -v /mnt/data:/mnt/database:Z mycontainer-image:v1
----

When the command above is run, a container called "mycontainer" is started on the host. It uses a container image called "mycontainer-image" with the tag "v1". It also maps the local folder /mnt/data to the folder within the container /mnt/database. The -v switch simply means "volume" and the ":Z" attribute is a security feature which we won't go into at this stage (it involves a security system called SELinux)

Once the container starts, if we were to look inside the container under /mnt/database, we would see that the content of that folder matches /mnt/data on the host. And crucially, we can both read a write data to this folder in real time. 

Now that the /mnt/database has persistence to a real storage device, each time the container stop and starts the pre-existing volume will be mounted and available for consumption by the container. This allows data persistance for any application that we want to design and run within a container eco system.


[#openshift_storage]
== OpenShift Storage

Local storage volumes are great for a small number of containers, but real world deployments of containerised applications can have hundreds if not thousands of containers running that all need persistent storage for data. This would quickly become difficult to manage manually using the methodology we have discussed so far. Happily, kubernetes and thefore Red Hat OpenShift has a technology which makes the provision and management of containerised storage relatively simple. It is called "Persitent Volumes" and "Persistent Volume Claims". A key thing to remember is however, that this technology still makes use of the volume mounts typology that we have breifly discussed "under the hood".

[#persistent_volumes]
== Persistent volumes

A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. A StorageClass provides a way for administrators to describe the "classes" of storage they offer. Beneath the storage class, real storage drives are obsficated from the administrator using a container storage interface.-  This infances takes care of the complicated process of accounting for all of the different types of storage regardless of vendor or cloud platform, making it simple and easy to consume by developers on a Kuberentes platform.

A persistent volume is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.

[#persistent_volume_claims]
== Persistent Volume Claims

A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes (e.g., they can be mounted ReadWriteOnce, ReadOnlyMany or ReadWriteMany, see AccessModes).

[#build_our_app]
== Build our App

To demonstrate how to use container storage with OpenShift, we will start by deploying a very simple web application container onto our cluster, and then interact with the local filesystem on that container via the terminal. To begin with, we will create a new project in OpenShift for this experiment. Fromt the developer view within OpenShift, click the drop down towards the top of the window and then select "Create Project"

image::08-02-create-project.png[container root filesystem,300,align="center"]

We will call this project:

[.console-input]
[source,bash,subs="+attributes"]
----
bootcamp-webserver
----


image::08-03-create-project-name.png[Enter a project name,400,align="center"]


With a blank project created, we will now create a deployment from the developer view, using the import from git strategy. We will also specify a container file which will define and create our application for us. Start by slecting the "Import from Git" option (make sure you are in "Developer View") as shown below:

image::08-04-import-from-git.png[import from git,300,align="center"]

We will now enter the git repository url that contains the code we are going to deploy to our cluster:


[.console-input]
[source,bash,subs="+attributes"]
----
https://github.com/mkimberley/bootcamp_webserver.git
----

image::08-05-git-repo-name.png[container root filesystem,700,align="center"]

We now need to tell OpenShift that we wish to specify a container file. The file "Containerfile" is at the root of the git repository we are using, and contains the build steps to make our container image.



image::08-06-containerfile.png[container root filesystem,700,align="center"]




[#test_storage_persistance]
== Test our Storage persistance



=== Step 1 - Without a Persistent Volume

image::08-07-verify-test.png[container root filesystem,700,align="center"]

image::08-08-scale-down-pod.png[container root filesystem,300,align="center"]

image::08-09-scale-up-pod.png[container root filesystem,300,align="center"]

image::08-10-test-persistence.png[container root filesystem,700,align="center"]


=== Step 2 - With a Persistent Voume

image::08-11b-deployment-storage.png[container root filesystem,700,align="center"]

image::08-12-pvc-post-scale.png[container root filesystem,700,align="center"]

image::08-13-testing-pvc.png[container root filesystem,700,align="center"]

[#add_storage_to_workshop]
== Adding a persistent volume to our Bootcamp app





https://kubernetes.io/docs/concepts/storage/persistent-volumes/